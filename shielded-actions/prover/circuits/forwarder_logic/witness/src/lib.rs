//! Forwarder Logic Witness
//!
//! A logic circuit witness that outputs external_payload for ERC20 forwarder calls.
//! This enables shield/unshield operations that transfer tokens via the Protocol Adapter.

use arm::{
    error::ArmError,
    logic_instance::{AppData, ExpirableBlob, LogicInstance},
    logic_proof::LogicProver,
    nullifier_key::NullifierKey,
    resource::Resource,
    resource_logic::LogicCircuit,
    utils::bytes_to_words,
};
use once_cell::sync::Lazy;
use risc0_zkvm::sha::Digest;
use serde::{Deserialize, Serialize};

/// The compiled forwarder logic guest program ELF binary
/// Generated by: cargo risczero build (in circuits/forwarder_logic/methods/guest)
pub const FORWARDER_LOGIC_ELF: &[u8] = include_bytes!("../forwarder-logic-guest.bin");

/// The image ID (verifying key) of the forwarder logic guest program
/// This was output during compilation: 09eb06dcde7c4febd4e9b26ca97ac21bdbd9e32dcd387ab232faac1924796a8f
pub static FORWARDER_LOGIC_IMAGE_ID: Lazy<Digest> = Lazy::new(|| {
    let bytes = hex::decode("09eb06dcde7c4febd4e9b26ca97ac21bdbd9e32dcd387ab232faac1924796a8f")
        .expect("Invalid image ID hex");
    let mut arr = [0u8; 32];
    arr.copy_from_slice(&bytes);
    Digest::from_bytes(arr)
});

/// Deletion criterion: Never delete (persists after transaction)
const DELETION_CRITERION_NEVER: u32 = 1;

/// Forwarder Logic Witness
///
/// This witness enables resources to trigger ERC20 forwarder calls when consumed/created.
/// The external_payload encodes: (forwarderAddress, calldata, expectedOutput)
#[derive(Clone, Default, Serialize, Deserialize)]
pub struct ForwarderLogicWitness {
    /// The resource being consumed or created
    pub resource: Resource,
    /// The action tree root for merkle path verification
    pub action_tree_root: Digest,
    /// Whether this is a consumed (true) or created (false) resource
    pub is_consumed: bool,
    /// The nullifier key for computing tags
    pub nf_key: NullifierKey,
    /// Forwarder contract address (20 bytes)
    pub forwarder_address: [u8; 20],
    /// Call data to send to forwarder (includes function selector)
    pub call_data: Vec<u8>,
    /// Expected output from forwarder call
    pub expected_output: Vec<u8>,
    /// Whether to include external_payload (only for specific resource roles)
    pub include_external_call: bool,
}

impl LogicCircuit for ForwarderLogicWitness {
    fn constrain(&self) -> Result<LogicInstance, ArmError> {
        // Compute the resource tag (nullifier for consumed, commitment for created)
        let tag = self.resource.tag(self.is_consumed, &self.nf_key)?;

        // For ephemeral resources, quantity must be 0
        if self.resource.is_ephemeral {
            assert_eq!(self.resource.quantity, 0, "Ephemeral resources must have quantity=0");
        }

        // Build external_payload if this resource should trigger a forwarder call
        let external_payload = if self.include_external_call && !self.call_data.is_empty() {
            // Encode as: abi.encode(forwarderAddress, calldata, expectedOutput)
            let blob_data = self.encode_forwarder_call();

            vec![ExpirableBlob {
                blob: bytes_to_words(&blob_data),
                deletion_criterion: DELETION_CRITERION_NEVER,
            }]
        } else {
            vec![]
        };

        let app_data = AppData {
            resource_payload: vec![],
            discovery_payload: vec![],
            external_payload,
            application_payload: vec![],
        };

        Ok(LogicInstance {
            tag,
            is_consumed: self.is_consumed,
            root: self.action_tree_root,
            app_data,
        })
    }
}

/// Implement LogicProver to enable proof generation
impl LogicProver for ForwarderLogicWitness {
    type Witness = ForwarderLogicWitness;

    fn proving_key() -> &'static [u8] {
        FORWARDER_LOGIC_ELF
    }

    fn verifying_key() -> Digest {
        *FORWARDER_LOGIC_IMAGE_ID
    }

    fn witness(&self) -> &Self::Witness {
        self
    }
}

impl ForwarderLogicWitness {
    /// Create a new witness for a shield operation (deposit tokens)
    pub fn new_shield(
        resource: Resource,
        action_tree_root: Digest,
        nf_key: NullifierKey,
        is_consumed: bool,
        forwarder_address: [u8; 20],
        sender: [u8; 20],
        amount: u128,
    ) -> Self {
        // For shield, the created resource triggers transferFrom
        let include_external_call = !is_consumed; // Created resource triggers the call

        let (call_data, expected_output) = if include_external_call {
            // transferFrom(from, to, amount) - from sender to forwarder
            let call_data = encode_transfer_from(sender, forwarder_address, amount);
            let expected_output = encode_bool(true);
            (call_data, expected_output)
        } else {
            (vec![], vec![])
        };

        Self {
            resource,
            action_tree_root,
            is_consumed,
            nf_key,
            forwarder_address,
            call_data,
            expected_output,
            include_external_call,
        }
    }

    /// Create a new witness for an unshield operation (withdraw tokens)
    pub fn new_unshield(
        resource: Resource,
        action_tree_root: Digest,
        nf_key: NullifierKey,
        is_consumed: bool,
        forwarder_address: [u8; 20],
        recipient: [u8; 20],
        amount: u128,
    ) -> Self {
        // For unshield, the consumed resource triggers transfer
        let include_external_call = is_consumed; // Consumed resource triggers the call

        let (call_data, expected_output) = if include_external_call {
            // transfer(to, amount) - from forwarder to recipient
            let call_data = encode_transfer(recipient, amount);
            let expected_output = encode_bool(true);
            (call_data, expected_output)
        } else {
            (vec![], vec![])
        };

        Self {
            resource,
            action_tree_root,
            is_consumed,
            nf_key,
            forwarder_address,
            call_data,
            expected_output,
            include_external_call,
        }
    }

    /// Create a witness with no external call (for padding/balance resources)
    pub fn new_no_call(
        resource: Resource,
        action_tree_root: Digest,
        nf_key: NullifierKey,
        is_consumed: bool,
    ) -> Self {
        Self {
            resource,
            action_tree_root,
            is_consumed,
            nf_key,
            forwarder_address: [0u8; 20],
            call_data: vec![],
            expected_output: vec![],
            include_external_call: false,
        }
    }

    /// Encode the forwarder call as ABI-encoded tuple: (address, bytes, bytes)
    fn encode_forwarder_call(&self) -> Vec<u8> {
        // ABI encode: (address forwarder, bytes calldata, bytes expectedOutput)
        // This matches the format expected by ProtocolAdapter._executeForwarderCall

        // Simple ABI encoding for (address, bytes, bytes)
        let mut result = Vec::new();

        // Offset for dynamic data starts after the 3 static slots (address + 2 offsets)
        // address is static (32 bytes, padded)
        // bytes offset 1 (32 bytes)
        // bytes offset 2 (32 bytes)

        // Address (padded to 32 bytes)
        result.extend_from_slice(&[0u8; 12]);
        result.extend_from_slice(&self.forwarder_address);

        // Offset to call_data (96 = 0x60)
        result.extend_from_slice(&[0u8; 31]);
        result.push(0x60);

        // Offset to expected_output (96 + 32 + call_data.len() padded to 32)
        let call_data_slot_size = 32 + ((self.call_data.len() + 31) / 32) * 32;
        let expected_offset = 96 + call_data_slot_size;
        result.extend_from_slice(&u256_to_bytes(expected_offset as u128));

        // call_data (length + data)
        result.extend_from_slice(&u256_to_bytes(self.call_data.len() as u128));
        result.extend_from_slice(&self.call_data);
        // Pad to 32 bytes
        let padding = (32 - (self.call_data.len() % 32)) % 32;
        result.extend_from_slice(&vec![0u8; padding]);

        // expected_output (length + data)
        result.extend_from_slice(&u256_to_bytes(self.expected_output.len() as u128));
        result.extend_from_slice(&self.expected_output);
        // Pad to 32 bytes
        let padding = (32 - (self.expected_output.len() % 32)) % 32;
        result.extend_from_slice(&vec![0u8; padding]);

        result
    }
}

/// Encode transferFrom(from, to, amount) call
fn encode_transfer_from(from: [u8; 20], to: [u8; 20], amount: u128) -> Vec<u8> {
    let mut data = vec![0x23, 0xb8, 0x72, 0xdd]; // transferFrom selector

    // from address (padded)
    data.extend_from_slice(&[0u8; 12]);
    data.extend_from_slice(&from);

    // to address (padded)
    data.extend_from_slice(&[0u8; 12]);
    data.extend_from_slice(&to);

    // amount (uint256)
    data.extend_from_slice(&u256_to_bytes(amount));

    data
}

/// Encode transfer(to, amount) call
fn encode_transfer(to: [u8; 20], amount: u128) -> Vec<u8> {
    let mut data = vec![0xa9, 0x05, 0x9c, 0xbb]; // transfer selector

    // to address (padded)
    data.extend_from_slice(&[0u8; 12]);
    data.extend_from_slice(&to);

    // amount (uint256)
    data.extend_from_slice(&u256_to_bytes(amount));

    data
}

/// Encode a boolean as ABI-encoded bytes
fn encode_bool(value: bool) -> Vec<u8> {
    let mut data = vec![0u8; 32];
    if value {
        data[31] = 1;
    }
    data
}

/// Convert u128 to 32-byte big-endian representation
fn u256_to_bytes(value: u128) -> [u8; 32] {
    let mut bytes = [0u8; 32];
    bytes[16..].copy_from_slice(&value.to_be_bytes());
    bytes
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_encode_transfer_from() {
        let from = [0x11u8; 20];
        let to = [0x22u8; 20];
        let amount = 1000000u128;

        let encoded = encode_transfer_from(from, to, amount);

        // Check selector
        assert_eq!(&encoded[0..4], &[0x23, 0xb8, 0x72, 0xdd]);
        // Check length: 4 + 32 + 32 + 32 = 100
        assert_eq!(encoded.len(), 100);
    }

    #[test]
    fn test_encode_transfer() {
        let to = [0x22u8; 20];
        let amount = 1000000u128;

        let encoded = encode_transfer(to, amount);

        // Check selector
        assert_eq!(&encoded[0..4], &[0xa9, 0x05, 0x9c, 0xbb]);
        // Check length: 4 + 32 + 32 = 68
        assert_eq!(encoded.len(), 68);
    }
}
